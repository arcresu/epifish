---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# epifish   

<!-- badges: start -->
<!-- badges: end -->

This package provides tools to use Chris Miller's fishplot package (https://github.com/chrisamiller/fishplot) with epidemiological datasets, to generate fishplot epi-curves. 

**Why?**  
A count matrix for a fishplot has a set of specific rules which an epidemiological dataset will not naturally fulfil:  

  -   cluster counts can never go completely to zero, if cases reappear later
  -   if a cluster has a parent/child relationship, at every timepoint the parent must always have >= the count of all its children.
  -   counts should be normalised to fit the fishplot y-axis

This package exists to make it easy to convert a list of samples into a normalised and appropriately "padded" relative count matrix that fulfils these requirements.


## Contents

  -   [Installation](#installation)
  -   [Quick demo](#quick-demo)
  -   [Input format](#input-format)
  -   [Output](#output)
  -   [Extras](#extras)
      -   [Using raw dates to create timepoints](#using-raw-dates-to-create-timepoints)
          -   [Calculate epi weeks and text labels](#calculate-epi-weeks-and-text-labels)
          -   [Use epi months as timepoints](#use-epi-months-as-timepoints)
      -   [Using informative timepoint labels](#using-informative-timepoint-labels)
      -   [Manual timepoints and labels](#manual-timepoints-and-labels)
      -   [Control legend spacing](#control-legend-spacing)
  -   [Citation](#citation)


## Installation

You can install epifish with: 
``` r
#install devtools if you don't have it already
install.packages("devtools")

#then load devtools & install epifish
library(devtools)
devtools::install_github("learithe/epifish")
```
  
## Quick demo

Load epifish and required packages
``` r 
library(fishplot); library(dplyr); library(tidyr); library(lubridate); library(epifish)
```
```{r, include=FALSE}
library(fishplot); library(dplyr); library(tidyr); library(lubridate); library(epifish); library(knitr); library(kableExtra)
```

Read in the table of sample data, parent-child relationships, and custom colour scheme:
```r
sample_df <- read.csv("epifish/inst/extdata/samples.csv", stringsAsFactors=FALSE)
parent_df <- read.csv("epifish/inst/extdata/parents.csv", stringsAsFactors=FALSE)
colour_df <- read.csv("epifish/inst/extdata/colours.csv", stringsAsFactors=FALSE)
```

Use epifish to convert this into a fishplot object, with extra assorted summary information:
```{r}
epifish_output <- epifish::build_epifish( sample_df, parent_df=parent_df, colour_df=colour_df)
```

Then use the fishplot package to generate a fishplot:
```{r}
fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", 
                   vlines=epifish_output$timepoints, vlab=epifish_output$timepoints)
fishplot::drawLegend(epifish_output$fish, nrow=1)

```

If you're happy with the default colours, or all your clusters are independent, you don't need those  dataframes:
```{r}
epifish_output <- epifish::build_epifish( sample_df )

fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", 
                   vlines=epifish_output$timepoints, vlab=epifish_output$timepoints)
fishplot::drawLegend(epifish_output$fish, nrow=1)

```


You also can automatically collapse any clusters of a minimum size into a group with `min_cluster_size`:  
*Note: this does not work with parent/child relationships if any child clusters are small!*   
``` {r}
epifish_output <- epifish::build_epifish(sample_df, colour_df=colour_df, min_cluster_size=10)

fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", vlines=epifish_output$timepoints, vlab=epifish_output$timepoints)
fishplot::drawLegend(epifish_output$fish, nrow=1)

```



## Input format

Example input files/templates can be found in the `inst/extdata` folder in this repository. The basic requirement is a data frame containing one row per sample, with columns `cluster_id` and `timepoint` (any other columns are ignored). 

Optional data frames may also be provided that describe parent-child relationships for clusters (eg cluster A.1 evolved from cluster A), or a custom colour scheme.

It is easiest and safest (especially when working with dates) to save and maintain these tables in `.csv` (comma-separated values) format, and to read them into R using `read.csv("filename", stringsAsFactors=FALSE)` as shown in the example above. However you can use whatever methods you want to create these dataframes, as long as they contain the required columns in character or numeric (NOT factor) format.


**the last few rows of sample data:**  
(Note that the order doesn't matter)
```{r echo=F}
kable(tail(sample_df), row.names=FALSE)
```

**the parent-child data:**
```{r echo=F}
options(knitr.kable.NA = '') 
kable(parent_df)
```

**a custom colour scheme:**
```{r echo=F}
kable(colour_df)
```


## Output

The output of epifish is a list variable containing: a fishplot object (`epifish_output$fish`), the data structures needed to generate it, and some extra data summary tables:

  -   `fish` fishplot object to pass to `fishplot::fishPlot()`
  -   `timepoint_counts` summary table of number of samples per cluster per timepoint
  -   `timepoint_sums` summary table of number of samples per timepoint
  -   `cluster_sums` summary table of total number of samples per cluster
  -   `timepoints` vector of timepoints used
  -   `timepoint_labels` vector of the names of timepoints assigned in the plot
  -   `parents` named list matching child clusters to their parent's position in the matrix (0 means cluster is independent)
  -   `raw_table` initial table of counts per cluster per timepoint, before padding and normalisation
  -   `fish_table` normalised and parent-padded table for the epi-fishplot
  -   `fish_matrix` final transformed matrix used to make the epifish object

This can be used with the fishplot package's fishPlot() function to generate an R plot image, as shown above. If using RStudio, it is most straightforward to save the R plot as PDF image from the RStudio plot window (Export -> "Save as PDF").


If you wish to save individual tables from the output list for any reason, it can be done like so:
``` r
write.csv(epifish_output$fish_table, "fishplot_table.csv", row.names=FALSE)
```

This is the extra summary data that epifish creates:
```{r}

epifish_output <- epifish::build_epifish( sample_df, parent_df=parent_df, colour_df=colour_df)


epifish_output$timepoint_counts

epifish_output$timepoint_sums

epifish_output$cluster_sums

epifish_output$parents

epifish_output$timepoints

epifish_output$timepoint_labels

epifish_output$raw_table

epifish_output$fish_table

#this is the final matrix used to generate the epifish fishplot object
epifish_output$fish_matrix
```






## Extras
  
  
### Using raw dates to create timepoints
Epifish also has a few functions to make it easy to convert dates to epidemic weeks or months (to use as timepoints), and generate label-friendly versions of timepoint dates.  

*NOTE: when working with dates in both R and Excel, be sure to check that your values match what you expect! When using R for analysis it is best practice tosave your data files in a text-based format like `.csv` (comma-separated-value) format rather than Excel format, because [Excel has many issues with how it handles dates](https://datacarpentry.org/spreadsheets-socialsci/03-dates-as-data/), and using a text-only format avoids having your dates messed up by Excel.*

#### Calculate epi weeks and text labels
Given a date column name (`date_of_collection` here), the start date of the epidemic, and the date format, you can use `get_epiweek()` to calculate the number of weeks since the start of the epidemic each sample belongs to, and `get_epiweek_span()` to give the epi week a clear text label. *Note: these functions have customisation options, check their documentation for details.*
``` {r}
#calculate epiweek timepoints from the column "date_of_collection" & create text labels to match them
sample_df <- sample_df %>% rowwise() %>% 
             mutate("epiweek"= epifish::get_epiweek(cdate = date_of_collection, 
                                                    start_date = "1/1/20", 
                                                    date_format = "dmy"))

#create a timepoint label column that gives the last day of each epi week the sample was collected in:
sample_df <- sample_df %>% rowwise() %>% 
             mutate("epiweek_label"= epifish::get_epiweek_span(cdate = date_of_collection, 
                                                                date_format = "dmy",
                                                                return_end = TRUE, 
                                                                newline=TRUE))

#look at what we created 
kable( tail(sample_df) )

```

   
   
### Using informative timepoint labels
If you call `build_epifish ()` with `timepoint_labels=TRUE`, epifish will look for a column called `timepoint_label` to use as the timepoint labels. (You can also set this up as a column in your input file, rather than calculating it as shown here.) *Note: you can only have one unique label per timepoint value.*  

#### Use calculated epi weeks as the timepoints
``` {r}
#fill the "timepoint" and "timepoint_label" columns with our newly calculated epi weeks above
sample_df$timepoint <- sample_df$epiweek  
sample_df$timepoint_label <- sample_df$epiweek_label

#tell epifish to use the "timepoint_label" column we just created
epifish_output <- epifish::build_epifish( sample_df, parent_df, colour_df, timepoint_labels=TRUE)

fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", 
                   vlines=epifish_output$timepoints, vlab=epifish_output$timepoint_labels)
fishplot::drawLegend(epifish_output$fish, nrow=1)
```


#### Use epi months as timepoints:  
Epifish also has `get_epimonth()` and `get_month_text()` functions for calculating epi months from dates:

``` {r}

#create a "epimonth" timepoint:
sample_df <- sample_df %>% rowwise() %>% 
             mutate("timepoint"= epifish::get_epimonth(cdate = date_of_collection, 
                                                      start_date = "1/1/20", 
                                                      date_format = "dmy")) 
#and an epimonth label
sample_df <- sample_df %>% rowwise() %>% 
             mutate("timepoint_label"= epifish::get_month_text(cdate = date_of_collection, 
                                                              date_format = "dmy")) 

#tell epifish to use the "timepoint_label" column we created above
epifish_output <- epifish::build_epifish( sample_df, parent_df, colour_df, timepoint_labels=TRUE)

#use "polygon" shape here as "spline" and "bezier" have some issues...
fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="polygon", 
                   vlines=epifish_output$timepoints, vlab=epifish_output$timepoint_labels)
fishplot::drawLegend(epifish_output$fish, nrow=1, xpos=0.7)
```


   
### Manual timepoints and labels

The fishplot package provides flexibility in where to display the vertical lines and what text to show, which can be used to create custom combinations rather than using the epifish default:
  

You can plot every other week:
``` {r}
#calculate use the epiweek timepoints
sample_df$timepoint <- sample_df$epiweek
sample_df$timepoint_label <- sample_df$epiweek_label

#run epifish
epifish_output <- epifish::build_epifish( sample_df, parent_df, colour_df, timepoint_labels=TRUE)

#subset timepoints and labels to ever other entry
vlines <- epifish_output$timepoints[c(TRUE, FALSE)]
vlabs  <- epifish_output$timepoint_labels[c(TRUE, FALSE)]

#plot
fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", 
                   vlines=vlines, vlab=vlabs)

```


Or add a "zero" timepoint with the first case, which starts on the fourth day of the first epi week (we'll also make the text a bit smaller so it doesn't overlap):
``` {r}
vlines <- c((4/7), epifish_output$timepoints)
vlabs <- c("1\nJan", epifish_output$timepoint_labels)

fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", 
                   vlines=vlines, vlab=vlabs, cex.vlab=0.5)

```

Or we can use completely custom timepoints and labels that describe an epidemiological story, with red lines:
``` {r}
vlines <- c((4/7), 3, 4, 8, 14)
vlabs <- c("first\ncases", "peak 1", "quarantine\n", "quarantine\nlifted", "peak 2")

fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", 
                   vlines=vlines, vlab=vlabs, col.vline="red")

```

   
### Control legend spacing 
You can use `epifish::drawLegend2()` to modify the spacing of the epi-fishplot legend, which is especially useful with long cluster names.  Use `widthratio` to adjust the width between columns relative to the longest cluster name (smaller value = more space), and `xsp` to control space between the colour box and the text (larger = more space)
```{r, include=FALSE}
epifish_output <- build_epifish (sample_df, parent_df, colour_df)
```

**default `fishplot::drawLegend()`:**
``` {r}
fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", vlines=epifish_output$timepoints, vlab=epifish_output$timepoint_labels)
fishplot::drawLegend(epifish_output$fish, nrow=2)
```

**using `epifish::drawLegend2()` to adjust the legend spacing:**
``` {r}
fishplot::fishPlot(epifish_output$fish, pad.left=0.1, shape="spline", vlines=epifish_output$timepoints, vlab=epifish_output$timepoint_labels)
epifish::drawLegend2(epifish_output$fish, nrow=2, widthratio=0.3, xsp=0.2)
```





## Citation:

**If you use epifish in your work, please don't forget to cite the fishplot package as well:**   
Visualizing tumor evolution with the fishplot package for R. Miller CA, McMichael J, Dang HX, Maher CA, Ding L, Ley TJ, Mardis ER, Wilson RK. BMC Genomics. doi:10.1186/s12864-016-3195-z





