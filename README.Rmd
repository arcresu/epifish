---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# epifish   

<!-- badges: start -->
<!-- badges: end -->

This package provides tools to use Chris Miller's fishplot package (https://github.com/chrisamiller/fishplot) with epidemiological datasets, to generate fishplot epi-curves. 


## Why?

A count matrix for a fishplot has a set of specific rules which an epidemiological dataset will not naturally fulfill:  
  * cluster counts can never go completely to zero, if cases reappear later  
  * if a cluster has a parent/child relationship, at every timepoint the parent must always have >= the count of all it's children.  
  * counts should be normalised to fit the fishplot y-axis  

This package exists to make it easy to convert a list of samples into a normalised and appropriately "padded" relative count matrix that fulfils these requirements.



## Installation

You can install epifish with: 
``` r
#install devtools if you don't have it already for easy installation
install.packages("devtools")
library(devtools)
devtools::install_github("learithe/epifish")
```
  
## Quick demo

Load epifish and required packages
``` r 
library(fishplot); library(dplyr); library(tidyr); library(lubridate); library(epifish)
```
```{r, include=FALSE}
library(fishplot); library(dplyr); library(tidyr); library(lubridate); library(epifish); library(knitr); library(kableExtra)
```

Read in the table of sample data, parent-child relationships, and custom colour scheme:
```r
sample_df <- read.csv("epifish/inst/extdata/samples.csv", stringsAsFactors=FALSE)
parent_df <- read.csv("epifish/inst/extdata/parents.csv", stringsAsFactors=FALSE)
colour_df <- read.csv("epifish/inst/extdata/colours.csv", stringsAsFactors=FALSE)
```

Use epifish to convert this into a fishplot-ready relative count matrix, fishplot object, and assorted summary information:
```{r}
epifish_list <- epifish::build_fishplot_tables(sample_df, parent_df=parent_df, colour_df=colour_df)
```

Then use the fishplot package to generate a fishplot:
```{r}
fishplot::fishPlot(epifish_list$fish, pad.left=0.1, shape="spline", vlines=epifish_list$timepoints, vlab=epifish_list$timepoints)
fishplot::drawLegend(epifish_list$fish, nrow=1)

```

If you're happy with the default colours, or all your clusters are independent, you don't need the parent or colour dataframes:
```{r}
epifish_list <- epifish::build_fishplot_tables(sample_df)
fishplot::fishPlot(epifish_list$fish, pad.left=0.1, shape="spline", vlines=epifish_list$timepoints, vlab=epifish_list$timepoints)
fishplot::drawLegend(epifish_list$fish, nrow=1)

```


You also can automatically collapse any clusters of a minimum size into a group with `min_cluster_size`:  
*Note: this does not work with parent/child relationships if any child clusters are small!*   
``` {r}
epifish_list <- build_fishplot_tables(sample_df, colour_df=colour_df, min_cluster_size=10)

fishplot::fishPlot(epifish_list$fish, pad.left=0.1, shape="spline", 
                   vlines=epifish_list$timepoints, vlab=epifish_list$timepoints)
fishplot::drawLegend(epifish_list$fish, nrow=1)

```


Take a look "under the hood" at the underlying matrix and data summaries that epifish generates:
```{r}

epifish_list <- epifish::build_fishplot_tables(sample_df, parent_df=parent_df, colour_df=colour_df)

epifish_list$timepoint_counts

epifish_list$timepoint_sums

epifish_list$cluster_sums

epifish_list$parents

epifish_list$timepoint_labels

epifish_list$raw_table

epifish_list$fish_table

#this is the final matrix used to generate the fishplot object epifishf
epifish_list$fish_matrix
```





## Input format

Example input files/templates can be found in the `inst/extdata` folder in this repository. The basic requirement is a data frame containing one row per sample, with columns `cluster_id` and `timepoint` (any other columns are ignored). 

Optional data frames may also be provided that describe parent-child relationships for clusters (eg cluster A.1 evolved from cluster A), or a custom colour scheme.

the last few rows of sample data:
```{r echo=F}
kable(tail(sample_df))
```

the parent-child data:
```{r echo=F}
kable(parent_df)
```

a custom colour scheme:
```{r echo=F}
kable(colour_df)
```


## Output

The output of epifish is a list variable containing: a fishplot object, the data structures needed to generate it, and some extra data summary tables. 

This can be used with the fishplot package's fishPlot() function to generate an R plot image, as shown above. If using RStudio, it is most straightforward to save the R plot as PDF image from the RStudio plot window (Export -> "Save as PDF").

If you wish to save individual tables from the output list for any reason, it can be done like so:
``` r
write.csv(epifish_list$fish_table, "fishplot_table.csv", row.names=FALSE)
```



## Extras
  
  
### Using raw dates to create timepoints
Epifish also has a few functions to make it easy to convert dates to CDC-defined epi weeks (to use as timepoints), and generate label-friendly versions of epi week dates.  

*NOTE: when working with dates in both R and Excel, be sure to check that your values match what you expect! When using R for analysis it is best practice tosave your data files in a text-based format like `.csv` (comma-separated-value) format rather than Excel format, because [Excel has many issues with how it handles dates](https://datacarpentry.org/spreadsheets-socialsci/03-dates-as-data/), and using a text-only format avoids having your dates messed up by Excel.*

``` {r}
#calculate epiweek timepoints from the column "date_of_collection" & create text labels to match them
sample_df <- sample_df %>% rowwise() %>% 
             mutate("epiweek"= epifish::get_epiweek(cdate = date_of_collection, 
                                                    start_date = "1/1/20", 
                                                    date_format = "dmy"))

#create a timepoint label column that gives the last day of each epi week the sample was collected in:
sample_df <- sample_df %>% rowwise() %>% 
             mutate("timepoint_label"= epifish::get_epiweek_span(cdate = date_of_collection, 
                                                                 return_end = TRUE, 
                                                                 date_format = "dmy")) 

#replace the space in the labels with a newline to look pretty
sample_df <- sample_df %>% rowwise() %>% 
             mutate("timepoint_label"= gsub(" ", "\n", timepoint_label))  
  
#create a "month" column just for fun:
sample_df <- sample_df %>% rowwise() %>% 
             mutate("month"= epifish::get_month(cdate = date_of_collection, 
                                                date_format = "dmy")) 

#look at what we created 
kable( tail(sample_df) )

```

   
   
### Use custom timepoint labels
If you call `build_fishplot_tables()` with `timepoint_labels=TRUE`, epifish will look for a column called "timepoint_label" to use as the timepoint labels. *Note: you can only have one unique label per timepoint value.*
``` {r}
#fill the "timepoint" column with our  newly calculated epi weeks above
sample_df$timepoint <- sample_df$epiweek  

#tell epifish to use the "timepoint_label" column we created above
epifish_list <- epifish::build_fishplot_tables(sample_df, parent_df, colour_df, timepoint_labels=TRUE)

fishplot::fishPlot(epifish_list$fish, pad.left=0.1, shape="spline", vlines=epifish_list$timepoints, vlab=epifish_list$timepoint_labels)
fishplot::drawLegend(epifish_list$fish, nrow=1)
```
  
  

### Specify timepoints and their labels manually

The fishplot package provides flexibility in where to display the vertical lines and what text to show, which can be used to create custom combinations rather than using the epifish default:
  
Say you want to add a "zero" timepoint with the first case, which starts on the fourth day of the first epi week (we'll also make the text a bit smaller so it doesn't overlap):
``` {r}
vlines <- c((4/7), epifish_list$timepoints)
vlabs <- c("1\nJan", epifish_list$timepoint_labels)

fishplot::fishPlot(epifish_list$fish, pad.left=0.1, shape="spline", 
                   vlines=vlines, vlab=vlabs, cex.vlab=0.5)

```


Or we can use completely custom labels that describe an epidemiological story, with red lines:
``` {r}
vlines <- c((4/7), 3, 4, 8, 14)
vlabs <- c("first\ncases", "peak 1", "quarantine\n", "quarantine\nlifted", "peak 2")

fishplot::fishPlot(epifish_list$fish, pad.left=0.1, shape="spline", 
                   vlines=vlines, vlab=vlabs, col.vline="red")

```



## Citation:

**If you use epifish in your work, please don't forget to cite the fishplot package:**   
Visualizing tumor evolution with the fishplot package for R. Miller CA, McMichael J, Dang HX, Maher CA, Ding L, Ley TJ, Mardis ER, Wilson RK. BMC Genomics. doi:10.1186/s12864-016-3195-z





